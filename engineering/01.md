# 前端工程简史

首先从岗位的角度来了解一下前端工程师

## 前端工程师的发展历史

### 一阶段

90年, web 发展的初期, 由于大环境的因素导致, 都是重后端, 并且页面基本上都是静态的, 前端所要做的就是一些简单的表单校验相关. 完全无法为止付出一个人力的资源.

结果就是不存在前端工程师一说.

### 二阶段

05年之后, AJAX 技术的问世, 带动了网页技术的发展, "异步请求", "局部刷新" 彻底的改变了网页交互模式, 可以说 Ajax 带活了前端. 同时, 在基础设施的不断提升, PC机器的普及(我家差不多也是在那几年时间买了第一台大头电脑, 很开心~), 网络的限流普及. 一切都在想着更加好的方向发展着, 以前所不能想想的东西现在都已经悄然而至...

不得不说, 基础设施的普及真的是一个会影响世界发展的因素. 环境的提升, 使的初期的前端工程师岗开始出现.

初期的前端岗几乎干的都是美化方面的问题, 所以那时候的前端都是设计出身, 前端岗算是一个"稍会编程的美工", 核心职责是通过 HTML 与 CSS 制作出更加精致的页面效果与体验, 也会在允许的情况下使用 Ajax 与 JavaScript.

### 三阶段

08年 Google 的 V8 诞生, 大大提高了 JavaScript 的运行性能, 这标志着 JavaScript 追逐战即将拉开序幕. 随后 Netscape 的 SpiderMonkey 参战, Apple 的 JavaScriptCore 参战.

神仙打架的结果就是, 浏览器的用户体验的到了质的飞跃, 过去所不能在客户端实现的功能都得意实现, 前端工程师可以施法的环境变好了, 施法规则变得更加清晰了!

REST(Representational State Transfer) 与 SPA(Single Page Application) 的方案被提出, 前端的职责变得不再简单.

### 四阶段

09年, Node.js 问世, 给前端界带来的体验就是, 卧槽?!

Node.js 将 JavaScript 带到了 Server 端开发的领域, 也正式 Node.js 的发展, "大前端" 模式开始蔓延.

Node.js 对前端生态的促进, 以及对实现前后端同构开发的支持力度是 PHP 等常见的 Server 开发所远不能及的.

## 前端工程师的技能栈

前端工程师的职能范围的发展是让人振奋的, 那么从初始至今, 前端岗所累计的技能有哪些?

- 硬技能: HTML/CSS/JavaScript

  这三个是前端工程师的核心技能, 也是最最基础的技能. HTML/CSS 更加倾向于领域特定语言, 而 JavaScript 却有所不同, 就现在而言它属于一门编程语言.
- 软技能: 用户体验

  如果你只是能做出功能点, 但是体验不好, 那也不能算是一名优秀的前端工程师. 那么 "体验" 到底指的是什么呢? 好的交互与视觉体验当然属于体验的一种, 但是减少等待时间, 保证流畅度, 减少移动设备的耗电也属于好的体验的考虑范围. 前端工程师不仅仅要求熟练的使用基本的开发技能, 还必须要具备性能优化的意识和技能.
- 扩展技能: Node.js 生态

  一个"`大前端`"所必备的素质之中, Node.js 生态(包括一些服务端的基础知识, Node.js 衍生产物)的熟练掌握是必不可少的. 有一点需要注意的是, 前端工程师需要了解一些后端的知识并不代表着需要去做后端开发, 目的只是为了更好的与后端协作, 并且在遇到了问题之后更好的定位.

> hack方案, 有时候由于浏览器直接的差异, 导致不得不实现一些兼容性的代码.

## Node.js 带来的改变

说到前端的改变, 不得不提的是 Ajax(A New Approach to Web Applications) 与 Node.js; Ajax 改变了传统的 web 交互模式, 使静态的页面"动"了起来; Node.js 的出现使的 JavaScript 不再仅仅是一个只能运行在浏览器中的脚本语言, 它已然可以用来进行服务端开发.

Node.js(简称为 Node) 并非一个 JavaScript 框架, 而是*一个集成了 Google V8 JavaScript引擎、事件驱动和底层 I/O API 的以 JavaScript 语言开发服务端应用的运行环境*. 与 PHP 不同的是, Node 可以直接提供网络服务, 也就是说不需要 Apache、Nginx、IIS 提供部署项目, 他自己就可以 host.

### JavaScript 服务端开发

老牌的服务端开发语言如 Java、PHP 已然是主流, 不过再一些特定的应用场景中也是非常适合使用 Node 来进行服务端开发的, Node 的事件驱动与异步I/O 使的其特别适合于开发实时应用、微服务、或长耗时操作, 当然前端工程化也离不开 Node.

### JavaScript 同构

同构(isomorphism) 是数学领域的专业术语, 指数学对象之间属性或者操作关系的一类映射. 在 JavaScript 而言, 同构就是指 JavaScript 编写的代码, 既可以在服务端执行, 也可以在客户端工作.

姑且可以将同构先更加针对性的理解为构建网页, 既可以在服务端构建, 又可以在客户端构建.

#### 服务端构建

传统网站的构建方式其实就是服务端构建, 例如传统 MVC 项目, 一般是用户请求某个页面, 服务端在收到请求后开始拼装页面, 最后将 HTML 整个返回给浏览器, 浏览器解析渲染出页面展示给用户.

服务端构建的特点是:

- 节省客户端资源
- SEO(Search Engine Optimization) 友好, 至少现在国内的搜索引擎还并不能像 Google 那么抓取 SPA 的信息

服务端构建的问题是:

- 频繁的 HTML 请求, 而且多数页面的请求都需要完全重新生成一次 HTML 文档(Ajax 并不是)
- 虽然服务器本身的性能就很强劲, 但是很明显服务端工作量很大, 因为是一个服务端对多个客户端服务的关系嘛

#### 客户端构建

PC 机与移动设备的性能的越发提升, 也使得客户端构建的道路被开辟出来. 服务端不在构建 HTML 文档, 而是通过 RESTFul API 提供 JSON 数据. 文档构建、路由跳转的工作都交由客户端自己来处理, 这种形式的应用被称为 SPA(Single Page Applicaation).

SPA 的特点是:

- 减轻服务端工作压力
- 减少网络流量
- 页面路由更加快速灵活
- 支持离线使用

SPA 的问题是:

- 首屏显示白屏
- 路由问题
- SEO 不友好

#### 同构

与传统的服务端构建和客户端构建相比, 同构 JavaScript 拥有更好的性能、可维护性、SEO友好的特点. Node 是实现同构 JavaScript 的关键.

Vue.js 与 React.js 都是支持同构开发的 JavaScript 框架.

### 前端工具

Node 除了可以做服务端开发之外, 同时也对前端孕育了丰富的工具生态, 如 Grunt、Gulp、Webpack.

## 前后端分离

说前后端分离之前先说一下传统的开发模式, 传统网站的开发.

传统网站的开发中, 往往需要前端工程师先根据设计好的UI把HTML模板先做出来, 然后后端人员在套用模板进行构建与数据填充. 开发的工作是串行化的, 每个环节都需要其前置环节工作的完成方可启动.

而前后端分离的开发模式则有所不同, 因为后端工程师不在需要提供 HTML 文档, 而是通过 RESTFul API 提供 JSON 数据的支持, 因此前端与后端的工作可以是并行的.

前后端分离的核心是解耦.

前后端分离所带来的好处是:

- 从开发的角度来看, 前端后端开发分离, 缩短了开发周期
- 从测试的角度来看, 前端后端职责分离, 使的定位问题更加快速、精准
- 从部署的角度来看, 前端后端动静分离, 简化部署流程, 增强了应用程序的健壮性

### 协作方式

1. 产出物

前后端分离基本模式中, 前端和后端首先要确定的就是职责范围.

前端工程师的产出物包括:

- HTML 文档
- CSS、图片等媒体资源
- JavaScript 逻辑

对前端工程师来说, 后端工程师的唯一产出就是数据.
2. 资源类型

- 静态资源

  JavaScript、CSS、图片等资源在浏览器的呈现方式是静态的
- 动态资源

  动态资源一般指的是 HTML 模板, 不需要任何服务端渲染的 SPA 不需要 HTML 模板.

HTML 模板的处理方案按照项目类型可以分为如下 3 种:

- SPA 类型项目, 没有 HTML 模板
- 传统服务端渲染, HTML 模板与服务端项目一起打包部署
- 大前端项目, 前端工程师负责静态文件与HTML模板

> 大前端并不是全栈工程师, 大前端不接触数据库操作, 大前端负责的是中间层, 而不是真正的服务层. 中间层的主要作用就是 HTML 的渲染, 一般使用 Node.js、PHP、Python 作为中间层开发语言.
3. 开发

前后端分离模式模式下的开发工作需要首先预定好接口规范与数据结构. 开发期间, 前端工程师按照规范使用 Mock 服务提供模拟数据进行开发工作.
4. 测试

前后端分离的测试分为两个阶段: 1. 独立测试; 2. 集成测试.

独立测试时, 前后端项目独立测试, 互不影响; 集成测试时整合前后端代码, 并且交由测试工程师测试
5. 部署

前后端分离在部署阶段要解决的问题是动静分离部署.

根据项目类型的不同, 部署方式也不一样:

- 大前端:

  静态资源部署到`静态文件服务器`, 动态资源(HTML 模板文件)与中间层一同部署到 `Web服务器`
- SPA:

  分别为 HTML 文件和其他静态资源设立不同的缓存策略, HTML 文件使用协商缓存策略*304*, 其他使用强制缓存 *200(from cache)*, `或者` 全部采用`协商缓存策略`

## 前端工程化

以前的前端资源，往往是以一种服务端资源的“附属品”的形式被一并打包发布的，开发者认为没有必要为了前端制定专门的工程化方案。

但是，随着前端需求和逻辑的不断加重，前端的工程化一种趋势。

### 前端工程化的衡量标准

快、准、稳。

- 开发

  快
- 测试

  快（降低集成测试的时间成本） + 准（提高集成测试的问题定位准确性）

- 部署

  稳（稳定上线）

### 前端工程化的进化历程

1. 混沌形态
2. 前后端分离形态

#### 混沌形态

前端写 demo，后端写逻辑、套模板， 包括传统 mvc 模式也属于混沌形态。

处于这种形态下，前端工程师的产出就成为了制约后端工程师工作的因素，他们之间的工作方式是串行化的，只要你那里阻塞了，那么下游就永远无法开始正常工作。

导致混沌形态开始变化的一个关键因素是 Ajax 的出现。

#### 前后端分离形态

Ajax 技术的问题不仅改变了 Web 页面的交互模式，也间接的提高了用户对于 Web 产品需求，从而促进了前端逻辑的不断复杂化。服务端工程师负责前端逻辑的开发模式被打破。

本身服务端的逻辑就比较复杂，再加上 Ajax 的出现导致客户端的逻辑也变得复杂化，这就使得原本就对前端定位为小打小闹，对前端技术不太关心的的后端工程师们更加的力不从心，索性就把前端逻辑都交由前端来负责。

当前端真正的独立开来做事情的时候，他们自然会想把开发环境搞得更加的“舒服”，所以有些问题是不得不去解决的：

- ES 规范与浏览器兼容性不一致
- CSS 写起来好烦
- 资源定位
- 图片压缩/base64 内嵌/CSS Sprites
- 模块依赖分析与压缩打包
- 部分代码依赖后端接口
- 部分资源需要借助后端工程师部署

**开发层面**

处理 ES 规范与浏览器兼容性问题可以是用 [Babel](https://babeljs.io/) 进行转换，CSS 的问题可以使用 LESS/SASS/SCSS 等替代，使用 r.js 压缩打包 AMD 的模块等。

如果每个项目都来处理这么一遍，且不说首先需要先知道有这些东西，其本身就是一件很繁琐的事情。

讲这些工具的功能进行整合，就是前端工程化的第一步：构建。

有了构建流程之后，前端工程师就可以使用更加高效的开发方式了，比如使用 ES2015、ES2016、ES2017 等进行开发，将成为一种常态；使用 LESS、SASS 编写样式而不用使用更加基础型的 CSS；使用 ES6 的模块化开发，更好的组织规划代码；构建工具图片压缩、自动生成 CSS Sprites等。

从开发层面上来讲，这种改变无疑是高效的。

**协作层面**

就前后端工程师直接的协作来讲，本身前后端分离理念便是为了更加高质量与更加高效，那么前后端分离以后，首当其冲应该着手去解决的问题就是前段依赖于后端接口所导致的串行化开发模式。

为了解决此问题，需要加入本地开发服务器，本地服务器最典型的应用就是 Mock 服务，通过提供模拟接口和数据，解决前段 JavaScript 对数据 API 的依赖问题，从而实现并行开发。

但 Mock 服务的前提是，必须要提前对接口规范达成协议。

本地服务的另外一个好处是，提高开发效率，他可以提供诸如：动态构建、浏览器自动刷新等功能。

基本上这个本地服务就是指 NodeJs 所提供的 Web Server。

**部署层面**

对于部署来说，要秉承动静分离的观念。就 SPA 应用来讲，动态的 HTML 渲染的工作一般在前端完成，后端的产出是无耦合的数据，所以这个时候如果前端出现了 Bug，那么不需要协调后端人员来做什么事情，前端人员自己就可以解决问题，同理后端亦是如此。

需要注意的一个问题是，前端在不是 SPA 应用时，可能会出现版本已经更新，但客户还未及时看到新的站点信息的这种“缓存”问题。通常通过使用协商缓存策略来便于线上资源的及时更新。

### 前端工程化的 3 个阶段

#### 本地工具链

前端工程化并不是工具化，是以规范工作流程为手段，以工具为实现媒介，最终提高工作效率，保证产品质量为目的。前端工程化是一系列工具和规范的组合，规范为蓝本，工具为实现。

工具的作用是将规范具体为功能，在一定程度上将开发者限定在既有规范内。比如使用 eslint 可以限制编码风格，使用脚手架可以限制项目文件结构等。

#### 管理平台

集中管理的云平台：

- 淡化环境差异性，保证产出的一致性
- 权限集中管理，提高安全性
- 项目版本集中管理，便于危机处理

#### 持续集成

前端有了构建和部署，后端也有了相应的阶段，两方的工作流是分离的，最终的融合工作仍然能以避免繁琐的人工操作。

无论是前端还是后端，版本的变动都应该是对应的。

前端的工程化实际上是为了在前后端分离的场景下更好的融入到整体 Web 工作流之中，最终实现 CI/CD。

## 工程化方案架构

目前市场上流行的前端工具大体分为 3 类：

1. 工作流管理工具，如：Grunt、Gulp
2. 构建工具，如：webpack、rollup
3. 整体解决方案，如：FIS、WeFlow

Grunt、Gulp 工作流管理工具本身不提供任何具体的功能，所有的构建、部署等功能都是由对应的插件提供。

webpack 虽然是近两年才崛起的构建工具，但是其迅速的发展为目前最流行的构建工具之一。生态圈非常庞大，与 Grunt、Gulp 相比也有过之而无不及。Tree Shaking 机制也是 webpack 被选择的重要因素。

FIS 是一套比较完整的前端工程化方案，它具备构建、部署、Mock 服务等基本的功能，其主要目标是为了解决百度团队内部的需求，所以存在一定的局限性，其构建功能对于们目前市场比较流行的技术支持也不是很好，需要编写插件实现。

### 工程化方案功能规划

- Yeoman 内核的脚手架
- Express 的本地服务器
- webpack 内核的构建系统
- SFTP 协议的远程部署

#### 命令行工具（CLI）

Node.js 开发命令行工具可以借助于 commander.js，它应该至少包括 4 个功能：

1. 初始化一个新项目，通常是 new、create 之类
2. 执行新项目进行开发，通常是 serve、start、dev 之类
3. 构建项目，通常是 build
4. 部署项目，通常是 deploy

#### 构建

共建系统是整个工程化方案中最重要也是最复杂的功能，主要解决的是前端开发层面的问题。

- ES 规范的转译
- CSS 预编译器
- PostCSS 处理 hack
- 自动创建 CSS Sprites
- 图片压缩与小图片 base64 内嵌
- JavaScript 模块化规范支持

#### 环境区分

一个前端项目的迭代周期自始至终需要经历 3 个阶段：开发、测试、部署。每个阶段的运行环境存在的着差异性，工程化方案需要针对 3 种运行环境提供相应的功能和策略，并且将配置开放给用户。比如开发环境使用 dev 配置，测试环境使用 testing 配置，生成环境使用 prod 配置。
