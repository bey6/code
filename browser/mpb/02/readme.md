# TCP 协议如何保证页面文件完整送达

## 数据包的传输

> 互联网实际上是一套理念和协议组成的体系架构。

互联网中的数据是通过数据包来传输的，当一个数据包无法承载所有信息时，会拆分成多个数据包发送。

### **I**nternet **P**rotocol

> 数据包要在互联网上进行传输，就要符合*网际协议（IP）*标准。

计算机的地址就成为 _IP 地址_，访问任何网站实际上只是你的机器向另外一台计算机请求信息。

当`主机 A`想要发送信息给`主机 B`时，会在发送的信息时，为每个数据包附加一个 `IP 头`，这个 `IP 头` 之中，包含了：

- IP Version: 版本
- 源 IP 地址（Host A）：
- 目标 IP 地址（Host B）：
- 生存期：有效期

传输的过程可以描述如下：

1. *上层*将信息转交给网络层
2. *网络层*在数据包的头部附加 `IP 头`，之后转发*底层*
3. *底层*通过物理链路将数据包传输给目标主机（Host B）
4. 总感觉中间省略了什么？？
5. 目标主机的网络层解析并`弹出 IP 头`，之后转发上层
6. *上层*拿到了信息

### **U**ser **D**atagram **P**rotocol

刚才之所以说是上层的原因是 IP 协议无法知道数据包是要传送给那个应用的，他是一个非常底层的协议，目的只是为了将信息从一个电脑传送给另一个电脑，之后的工作需要其他的协议来“接力”。

UDP（用户数据包协议）是一个建立在 IP 协议之上的协议，它在 IP 地址之上引入了*端口号*，通过端口号，UDP 可以知道数据包是要发送给哪个应用。

基于 UDP 可以扩充一下刚才打的 IP 传输过程描述：

1. *应用层*将信息转交给*传输层*
2. *传输层*在数据包的头部附加 `UDP 头`，之后转发*网络层*
3. *网络层*在数据包的头部附加 `IP 头`，之后转发*底层*
4. *底层*通过物理链路将数据包传输给目标主机（Host B）
5. 总感觉中间省略了什么？？
6. 目标主机*网络层*解析并`弹出 IP 头`，之后转发*传输层*
7. 目标主机*传输层*解析并`弹出 UDP 头`，之后转发*上层*
8. *应用层*拿到了信息

**UDP 传输非常的快速，它不关注数据包是否送达，如果数据包丢失，也不提供重发机制。**此外，当传输大文件时，UDP 无法知道不同的数据包的排列顺序，因此传输结束后无法还原大文件。

UDP 适用于如：视频聊天、游戏等场景

### **T**ransmission **C**ontrol **P**rotocol

有时候 UDP 无法满足要求，软件需要保证数据的可靠性，因此又有了 TCP（传输控制协议） 协议

对于 UDP 而言，TCP 有下面的改进：

- TCP 解决了 UDP 中数据包排列顺序的问题，支持大文件的传输
- TCP 对数据包的丢失提供了重传的机制

TCP 与 UDP 的传输过程是基本相同的，不同点在于 TCP 头保存了支持数据完整性的信息，那么 **TCP 具体是如何保证重传和排序的呢**？

![TCP 生命周期](./1.png)

#### 三次握手，为什么需要 `3` 次？

假设服务端和客户端都有 4 个因素需要确认，分别是，本身的收发能力和对方的收发能力

列个表吧：

| 相对于 | 客户端接收能力 | 客户端发送能力 | 服务端接收能力 | 服务端发送能力 |
| ------ | :------------: | :------------: | :------------: | :------------: |
| 客户端 |       ❓       |       ❓       |       ❓       |       ❓       |
| 服务端 |       ❓       |       ❓       |       ❓       |       ❓       |

以下收发均为缺省描述，比如说发送 `SYN` 并不是仅仅只发送了一个 `SYN`，几乎每一次收发都需要 `SEQ`。

1. 客户端发送 `SYN`
2. 服务端接收 `SYN`，发送 `ACK + SYN` 等，（服务端-客户端发送能力 ⭕，服务端-服务端接收能力 ⭕）；客户端接收 `ACK + SYN`（客户端-客户端发送能力 ⭕，客户端-客户端接收能力 ⭕，客户端-服务端接收能力 ⭕，客户端-服务端发送能力 ⭕）
3. 客户端发送 `ACK`，服务端接收 `ACK`（服务端-客户端接收能力 ⭕，服务端-服务端发送能力 ⭕）

至此
|相对于|客户端接收能力|客户端发送能力|服务端接收能力|服务端发送能力|
|-|:-:|:-:|:-:|:-:|
|客户端|⭕|⭕|⭕|⭕|
|服务端|⭕|⭕|⭕|⭕|

可以通讯啦！

#### 四次挥手，为什么又多了一次？

通过刚才的三次握手，需要指出的是，客户端和服务端都拥有收发能力，一端的发送指向另一端的接收，所以说 TCP 拥有双向传输的能力，在关闭的时候，需要关闭两个收发管道（还未找到更加详细的资料）。
再列一下吧

_挥手的发起者并不一定是客户端，这里只是统一文中的称呼而已_

1. 客户端发送 `FIN`，进入 `Fin-Wait-1` 状态，表明自己这边发完了，可以关闭了
2. 服务端收到 `FIN`，进入 `Close-Wait` 状态，发送 `ACK` 给客户端，客户端进入 `Fin-Wait-2` 状态
3. 等待服务端的发送任务结束后，服务端发送 `FIN` 给客户端，并进入 `Last_Ack` 状态
4. 客户端收到 `FIN`，进入 `Time_Wait` 状态，同时发送 `ACK` 给服务端，服务端进入 `Closed` 状态，之后客户端进入 `Closed` 状态

> 缩写的含义：
>
> **SYN**chronouse: 建立联机
>
> **ACK**nowledgement: 确认
>
> **P**u**SH**: 推
>
> **FIN**ish: 结束
>
> **R**e**S**e**T**: 重置
>
> **URG**ent: 紧急

## 小结 🌹

![xly.jpg](https://s1.ax1x.com/2020/04/07/G2FUgA.jpg)

_IP_ 可以把数据包发送到目标主机。

_UDP/TCP_ 负责吧数据包发送到具体的应用，_UDP_ 快速但不可靠，_TCP_ 可靠但连接比较复杂。
