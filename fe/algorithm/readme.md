# 数据结构与算法：复杂度分析

## 前言🌱

对于要学习数据结构与算法的同学来说，我们的出发点在于如何更好的处理问题，以达到合理、高效的目的。

*合理*就是某种数据结构与算法是适合于某个场景的，又或者他就是为了处理这个场景所进化而来的；*高效*则是在这些都*合理*的数据结构与算法中，我们应该有能力评判出那种组合可以更加的高效的解决问题。

通过我个人的学习经验来看，数据结构与算法的讨论往往围绕着如下的几点的复杂度来展开讨论：

- 排序
- 插入
- 删除
- 查找

一般来讲，排序的复杂度会从两个方面来考虑：*时间复杂度*与*空间复杂度*；其他的则着重讨论*时间复杂度*。

## 复杂度分析

实际上无论我们是否刻意的学习数据结构与算法，或者复杂度分析的方法，你的代码在写得越来越多的同时，自然而然也会有一种对性能的追求，比方说经常使用的关系型数据库的索引创建、尽量使用尾递归、更甚者是总是听到有人说代码不要那样写，那样会很慢！

通常来说，我自己会去真真的用代码执行一把，想办法搞明白为什么他会跟快。而这种通过执行代码来分析代码的方式就叫做*事后统计法*。事后统计法**眼见为实**，但是实际上他又受到了*目标规模*以及*机器环境*的影响，因此相对来说比较主观片面。

因此，数据结构与算法引入了*大 O 复杂度表示法*，他可以允许你在不执行代码的时候来粗略的评估算法的执行效率。

### 大 O 复杂度表示法

大 O 复杂度表示法将 CPU 执行一行代码的时间假设为 *unit_time*，并在此假设之上进行算法评估。

对于算法评估来讲，往往待评估的代码是与循环有关的，否则也无需评估，只需要数行数即可。所以我可对 `for 循环` 进行入门评估：

```js
function foo (n) {
  let sum = 0
  for (let i = 0; i < n; i++) {
    sum += i
  }
}
```

分析该代码的执行时间其实也是在*数行数*：

- `let sum = 0` 占用 `1 unit_time`
- `for (...)` 占用 `1 unit_time`
- `sum += i` 占用 `1 unit_time`
- 循环执行 *n* 次
  所以 `for(...) * n`、`sum += 1 * n`，也就是 `2n * unit_time`

所以最终执行时间为：`T(n) = (2n + 1) * unit_time`，
